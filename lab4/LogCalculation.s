LogCalculation(long double, long long):
        push    {r4, r5, r7, lr}       ; cохранение регистров, которыми будем пользоваться
        vpush.64        {d8}           ; Сохранение регистра с плавающей точкой
        sub     sp, sp, #48            ; Выделение места в стеке для локальных переменных
        add     r7, sp, #0             ; установка указателя на стек

        ; Размещение переменных в локальном стеке (стеке вызовов)
        vstr.64 d0, [r7, #8]           ; x (d0) сохраняется по адресу [r7 + 8]
        strd    r0, [r7]               ; n (r0) сохраняется по адресу [r7]

        mov     r2, #0                 ; res (начальное значение 0)
        mov     r3, #0                 ; prev (начальное значение 0)
        strd    r2, [r7, #40]          ; res (d0) сохраняется по адресу [r7 + 40]
        ldrd    r2, [r7, #8]           ; Загрузка x из стека
        strd    r2, [r7, #32]          ; prev (d2) сохраняется по адресу [r7 + 32]
        mov     r2, #0                 ; sign (начальное значение 0)
        mov     r3, #0
        movt    r3, 16368              ; sign (значение 1.0) сохраняется по адресу [r7 + 24]
        strd    r2, [r7, #24]
        mov     r2, #1
        mov     r3, #0
        strd    r2, [r7, #16]          ; i (начальное значение 1) сохраняется по адресу [r7 + 16]

        b       .L2                    ; Переход к циклу

.L3:
        vldr.64 d17, [r7, #24]         ; Загрузка sign (d17)
        vldr.64 d16, [r7, #32]         ; Загрузка prev (d16)
        vmul.f64        d8, d17, d16   ; d8 = sign * prev
        ldrd    r0, [r7, #16]          ; Загрузка i (r0)
        bl      __aeabi_l2d            ; Преобразование i в double
        vmov    d17, r0, r1            ; В d17 загружается результат
        vdiv.f64        d16, d8, d17   ; d16 = (sign * prev) / i
        vldr.64 d17, [r7, #40]         ; Загрузка res (d17)
        vadd.f64        d16, d17, d16  ; res += (sign * prev) / i
        vstr.64 d16, [r7, #40]         ; Сохранение результата обратно в res
        vldr.64 d17, [r7, #32]         ; Загрузка prev (d17)
        vldr.64 d16, [r7, #8]          ; Загрузка x (d16)
        vmul.f64        d16, d17, d16  ; prev *= x
        vstr.64 d16, [r7, #32]         ; Сохранение нового prev
        vldr.64 d16, [r7, #24]         ; Загрузка sign (d16)
        vneg.f64        d16, d16       ; sign = -sign
        vstr.64 d16, [r7, #24]         ; Сохранение нового sign
        ldrd    r2, [r7, #16]          ; Загрузка i (r2)
        adds    r4, r2, #1             ; i++
        adc     r5, r3, #0             ; Обновление r5 для i++
        strd    r4, [r7, #16]          ; Сохранение нового i

.L2:
        ldrd    r2, [r7, #16]          ; Загрузка i (r2)
        ldrd    r0, [r7]               ; Загрузка n (r0)
        cmp     r0, r2                 ; Сравнение i и n
        sbcs    r3, r1, r3             ; Обновление флагов
        bge     .L3                    ; Переход к циклу, если i <= n

        ldrd    r2, [r7, #40]          ; Загрузка res (r2)
        vmov    d16, r2, r3            ; В d16 загружается res
        vmov.f64        d0, d16        ; Возвращение результата в d0
        adds    r7, r7, #48            ; Восстановление указателя на стек
        mov     sp, r7                 ; Восстановление указателя стека
        vldm    sp!, {d8}              ; Восстановление регистра с плавающей точкой
        pop     {r4, r5, r7, pc}      ; Восстановление регистров и возврат из функции
